# -*- coding: utf-8 -*-
"""Genetic_Algorithm_Implementation1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yq6y-RNpTfP2P8f0rkQmSBI2UKLehvKR
"""

import random
import time
import matplotlib.pyplot as plt
import networkx as nx

# Define constants for Network Intiallization
IPRange = 50
IPSize = 15
timeout = 500
routeQtd = 8
destinationHost = "192.168.1.100"
sourceHost = "192.168.1.1"
selectionQtd = 4
lastDestinationOc = 100
lastSourceOc = 1

# Router Class
class Router:
    def __init__(self, ip, lastBinOc, nextTime, fitness):
        self.ip = ip
        self.nextRtd = None
        self.lastBinOc = lastBinOc
        self.nextTime = nextTime
        self.fitness = fitness
        self.jitter = 0

# Route Class
class Route:
    def __init__(self):
        self.firstRouter = None
        self.routeTime = 0
        self.fitnessSum = 0.0

# Function to remove repeated routers in the route
def remove_repeated(way):
    for i in range(routeQtd):
        iterator = way[i].firstRouter.nextRtd
        while iterator.nextRtd is not None:
            comparator = iterator.nextRtd
            while comparator.nextRtd is not None:
                if comparator.ip == iterator.ip:
                    remover = way[i].firstRouter.nextRtd
                    while remover.nextRtd != comparator:
                        remover = remover.nextRtd
                    remover.nextRtd = comparator.nextRtd
                    del comparator
                    break
                comparator = comparator.nextRtd
            iterator = iterator.nextRtd

# Function to create router with a given IP and last octet
def create_router(ip, lastIntOc):
    lastCharOc = format(lastIntOc, '08b')
    new_router = Router(ip, lastCharOc, random.randint(20, timeout), 0.0)
    return new_router

# Function to initialize a route
def initialize_route():
    new_route = Route()
    rtd = create_router(sourceHost, lastSourceOc)
    new_route.firstRouter = rtd
    new_route.routeTime = 0
    return new_route

# Function to add a router to a route
def add_router(way, ip, lastIntOc):
    iterator = way.firstRouter
    aux = create_router(ip, lastIntOc)

    while iterator.nextRtd is not None:
        iterator = iterator.nextRtd

    iterator.nextRtd = aux

# Function to detect repeated routers in a route
def detect_repeated(way, ip):
    iterator = way.firstRouter
    while iterator.nextRtd is not None:
        if iterator.ip == ip:
            return 0
        iterator = iterator.nextRtd
    if iterator.ip == ip:
        return 0
    return -1

# Function to construct a route
def mount_route():
    way = initialize_route()

    for _ in range(random.randint(3, IPRange + 2)):
        lastIntOc = random.randint(3, IPRange + 2)
        lastOc = str(lastIntOc)
        ip = "192.168.1." + lastOc

        if detect_repeated(way, ip) == -1:
            add_router(way, ip, lastIntOc)

    aux = way.firstRouter

    while aux.nextRtd is not None:
        aux = aux.nextRtd

    if aux.nextRtd is None:
        last = create_router(destinationHost, lastDestinationOc)
        last.nextTime = -1
        aux.nextRtd = last

    aux = way.firstRouter

    while aux.nextTime != -1:
        way.routeTime += aux.nextTime
        aux = aux.nextRtd

    return way

# Function for population initialization of routes
def initialize():
    way = mount_route()
    return way

# Function to display information about routes - Total Time and Route Fitness Value
def show(way):
    for i in range(routeQtd):
        print(f"Route {i + 1}\n")
        aux = way[i].firstRouter

        while aux is not None:
            print(f"IP: {aux.ip} - Latency to next router: {aux.nextTime}ms - Last octet binary: {aux.lastBinOc} - Fitness Jump: {aux.fitness}")
            aux = aux.nextRtd

        print(f"Total Time: {way[i].routeTime}ms")
        print(f"Route Fitness: {way[i].fitnessSum}\n\n")

# Function to update total latencies in each route
def update_total_latencies(way):
    for i in range(routeQtd):
        iterator = way[i].firstRouter
        way[i].routeTime = 0
        last_time = None
        while iterator.nextRtd is not None:
            if last_time is not None:
                iterator.jitter = abs(iterator.nextTime - last_time)
            last_time = iterator.nextTime
            way[i].routeTime += iterator.nextTime
            iterator = iterator.nextRtd

IPRange = 50
routeQtd = 8
destinationHost = "192.168.1.100"
sourceHost = "192.168.1.1"
lastDestinationOc = 100
lastSourceOc = 1

# Function for fitness evaluation
def evaluate_fitness(way):
    for i in range(routeQtd):
        iterator = way[i].firstRouter
        way[i].fitnessSum = 0

        while iterator.nextRtd is not None:
            latency_fitness = 1.0 / iterator.nextTime
            jitter_fitness = 1.0 / (iterator.jitter + 0.00001)
            iterator.fitness = latency_fitness + jitter_fitness

            iterator = iterator.nextRtd

        way[i].fitnessSum = 1.0 / (way[i].routeTime + 0.00001)

# Function to perform elitism
def make_elitism(way):
    iterator = way[routeQtd - 2].firstRouter.nextRtd
    faster = iterator
    smallerTime = iterator.nextTime

    while iterator.nextRtd is not None:
        if smallerTime > iterator.nextTime:
            smallerTime = iterator.nextTime
            faster = iterator
        iterator = iterator.nextRtd

    iterator = way[routeQtd - 1].firstRouter.nextRtd
    slower = iterator
    greaterTime = iterator.nextTime

    while iterator.nextRtd is not None:
        if greaterTime < iterator.nextTime:
            greaterTime = iterator.nextTime
            slower = iterator
        iterator = iterator.nextRtd

    slower.ip = faster.ip
    slower.nextTime = faster.nextTime
    slower.lastBinOc = faster.lastBinOc
    slower.fitness = faster.fitness

# Function to count routers in a route
def count_routers_in_route(route):
    count = 0
    iterator = route.firstRouter

    while iterator is not None:
        count += 1
        iterator = iterator.nextRtd

    return count

# Crossover Function
def make_crossover(way):
    routes_size = [count_routers_in_route(way[i]) for i in range(routeQtd)]

    smaller_route = min(routes_size)

    crossoved = [0 for _ in range(routeQtd)]
    method = random.randint(0, 2)

    for i in range(routeQtd):
        if method == 1:
            if crossoved[i] == 0:
                separation_point = 1 + random.randint(1, smaller_route)
                print(f"SEPARATION POINT {i + 1} - {i + 3}: {separation_point}")
                if smaller_route == separation_point or separation_point > smaller_route:
                    separation_point = 1

                iterator_route1 = way[i].firstRouter
                iterator_route2 = way[i + 2].firstRouter

                for j in range(separation_point - 1):
                    iterator_route1 = iterator_route1.nextRtd
                    iterator_route2 = iterator_route2.nextRtd

                aux = create_router("0.0.0.0", 0)

                aux.nextRtd = iterator_route1.nextRtd
                iterator_route1.nextRtd = iterator_route2.nextRtd
                iterator_route2.nextRtd = aux.nextRtd

                crossoved[i] = 1
                crossoved[i + 2] = 1

        if method == 0:
            if crossoved[i] == 0:
                separation_point = 1 + random.randint(1, smaller_route)
                print(f"SEPARATION POINT {i + 1} - {i + 2}: {separation_point}")
                if smaller_route == separation_point or separation_point > smaller_route:
                    separation_point = 1

                iterator_route1 = way[i].firstRouter
                iterator_route2 = way[i + 1].firstRouter

                for j in range(separation_point - 1):
                    iterator_route1 = iterator_route1.nextRtd
                    iterator_route2 = iterator_route2.nextRtd

                aux = create_router("0.0.0.0", 0)

                aux.nextRtd = iterator_route1.nextRtd
                iterator_route1.nextRtd = iterator_route2.nextRtd
                iterator_route2.nextRtd = aux.nextRtd

                crossoved[i] = 1
                crossoved[i + 1] = 1

        if method == 2:
            if crossoved[i] == 0:
                separation_point = 1 + random.randint(1, smaller_route)
                print(f"SEPARATION POINT {i + 1} - {routeQtd - i}: {separation_point}")
                if smaller_route == separation_point or separation_point > smaller_route:
                    separation_point = 1

                iterator_route1 = way[i].firstRouter
                iterator_route2 = way[routeQtd - i - 1].firstRouter

                for j in range(separation_point - 1):
                    iterator_route1 = iterator_route1.nextRtd
                    iterator_route2 = iterator_route2.nextRtd

                aux = create_router("0.0.0.0", 0)

                aux.nextRtd = iterator_route1.nextRtd
                iterator_route1.nextRtd = iterator_route2.nextRtd
                iterator_route2.nextRtd = aux.nextRtd

                crossoved[i] = 1
                crossoved[routeQtd - i - 1] = 1

    print("\n\n")

routeQtd = 8

# Function to run specified generations

def run_all_generations(way, generations_to_run):
    continue_execution = 1
    generation_count = 1

    while continue_execution == 1 and generation_count <= generations_to_run:
        make_crossover(way)
        make_elitism(way)
        remove_repeated(way)
        update_total_latencies(way)
        evaluate_fitness(way)
        generation_count += 1

    print("All generations completed.")

# Function to collect value of total times and route fitnesses across generations

def collect_generations_history(way, generations_to_run):
    total_times_history = {f'Route {i}': [] for i in range(1, len(way) + 1)}
    route_fitnesses_history = {f'Route {i}': [] for i in range(1, len(way) + 1)}

    for generation_count in range(1, generations_to_run + 1):
        make_crossover(way)
        make_elitism(way)
        remove_repeated(way)
        update_total_latencies(way)
        evaluate_fitness(way)
        total_times = [route.routeTime for route in way]
        route_fitnesses = [route.fitnessSum for route in way]
        for i, route_num in enumerate(range(1, len(way) + 1)):
            total_times_history[f'Route {route_num}'].append(total_times[i])
            route_fitnesses_history[f'Route {route_num}'].append(route_fitnesses[i])

    return total_times_history, route_fitnesses_history

# Plotting Function for total time for a route over defined generations
def plot_total_time(generations, total_times, route_num):
    route_label = f'Route {route_num}'
    plt.figure(figsize=(8, 4))
    plt.plot(generations, total_times, label=route_label)
    plt.xlabel('Generation')
    plt.ylabel('Total Time')
    plt.title(f'Total Time for {route_label} Over Generations')
    plt.legend()
    plt.grid(True)
    plt.show()

# Plotting Function for fitness values for a route over defined generations

def plot_fitness_values(generations, fitness_values, route_num):
    route_label = f'Route {route_num}'
    plt.figure(figsize=(8, 4))
    plt.plot(generations, fitness_values, label=route_label, color='green')  # You can adjust the color
    plt.xlabel('Generation')
    plt.ylabel('Fitness')
    plt.title(f'Fitness for {route_label} Over Generations')
    plt.legend()
    plt.grid(True)
    plt.show()

# Function to select the top routes based on fitness

def select_top_routes(way, top_n=3):
    sorted_routes = sorted(way, key=lambda route: route.fitnessSum)
    lowest_fitness_routes = sorted_routes[:top_n]
    return lowest_fitness_routes

top_routes_ips = []

def main():
    generations_to_run = 200

    # INITIALIZING THE ROUTES POPULATION
    way = [initialize() for _ in range(routeQtd)]

    print(f"Generation 0:\n\n")  # Initial generation
    show(way)

    print(f"Do you want to continue route crossover? 1-yes, 0-no (Remaining generations: {generations_to_run}) ")
    user_input = input().strip()
    continue_execution = int(user_input)
    print("\n\n")

    if continue_execution == 1:
        total_times_history, route_fitnesses_history = collect_generations_history(way, generations_to_run)

        # Print Total Time and Total Fitness for each route
        for route_num in range(1, len(way) + 1):
            route_label = f'Route {route_num}'
            print(f"\n{route_label}:\n")

            total_times = total_times_history[route_label]
            route_fitnesses = route_fitnesses_history[route_label]

            for generation, (total_time, fitness) in enumerate(zip(total_times, route_fitnesses), start=1):
                print(f"Generation {generation}: Total Time - {total_time}, Total Fitness - {fitness}")

            # Plot Total Time for each route after all GA is complete
            plot_total_time(range(1, generations_to_run + 1), total_times, route_num)

            # Plot Fitness Values for each route after GA is complete
            plot_fitness_values(range(1, generations_to_run + 1), route_fitnesses, route_num)

        # Select and print the top 3 routes
        top_routes = select_top_routes(way, top_n=4)
        print("\nTop 3 Routes:")
        for i, route in enumerate(top_routes, start=1):
            print(f"Route {i}: Total Fitness - {route.fitnessSum}")

            # Find and print all nodes in the route
            nodes_in_route = find_nodes_in_route(route)
            print(f"Nodes in Route {i}: {nodes_in_route}")

        for route_num, route in enumerate(way, start=1):
            print(f"\nRoute {route_num} Fitness: {route.fitnessSum}")

    print("Simulation completed.")

if __name__ == "__main__":
    main()

# Function to highlight the selected GA nodes
def plot_routes_with_color(way, colored_ips):
    G = nx.Graph()

    for i, route in enumerate(way):
        aux = route.firstRouter

        while aux is not None:
            G.add_node(aux.ip)

            if aux.nextRtd is not None:
                G.add_edge(aux.ip, aux.nextRtd.ip, weight=aux.nextTime)

            aux = aux.nextRtd

    plt.figure(figsize=(15, 15))

    pos = nx.spring_layout(G, scale=0.9)

    # Color nodes based on conditions
    node_colors = []
    for node_ip in G.nodes:
        if node_ip in ["192.168.1.1", "192.168.1.100"]:
            node_colors.append("lightcoral")
        elif node_ip in colored_ips:
            node_colors.append("lightgreen")
        else:
            node_colors.append("skyblue")

    nx.draw(G, pos, with_labels=True, node_size=400, node_color=node_colors, font_size=6)
    nx.draw_networkx_edge_labels(G, pos, edge_labels={}, font_size=6)

    plt.title("Green Nodes: Best Route using Genetic Algorithm")
    plt.show()

colored_ips = {'192.168.1.29', '192.168.1.42', '192.168.1.43', '192.168.1.25', '192.168.1.8', '192.168.1.1', '192.168.1.100', '192.168.1.21', '192.168.1.3', '192.168.1.23', '192.168.1.16'}

way_generation_0 = [initialize() for _ in range(routeQtd)]
plot_routes_with_color(way_generation_0, colored_ips)

# Function to create a graph and visualize the initial routes in a genetic algorithm - Generation 0 routes and nodes

def plot_routes(way):
    G = nx.Graph()

    for i, route in enumerate(way):
        aux = route.firstRouter

        while aux is not None:
            G.add_node(aux.ip)
            if aux.nextRtd is not None:
                G.add_edge(aux.ip, aux.nextRtd.ip, weight=aux.nextTime)

            aux = aux.nextRtd

    plt.figure(figsize=(12, 12))

    pos = nx.spring_layout(G, scale=0.9)

    node_colors = ["lightcoral" if node_ip in ["192.168.1.1", "192.168.1.100"] else "skyblue" for node_ip in G.nodes]

    nx.draw(G, pos, with_labels=True, node_size=700, node_color=node_colors, font_size=6)
    nx.draw_networkx_edge_labels(G, pos, edge_labels={}, font_size=6)

    plt.title("Generation 0: Initial Routes")
    plt.show()

way_generation_0 = [initialize() for _ in range(routeQtd)]
plot_routes(way_generation_0)

# Function to find and return all nodes (IP addresses) in a given route
def find_nodes_in_route(route):
    nodes = set()
    iterator = route.firstRouter

    while iterator is not None:
        nodes.add(iterator.ip)
        iterator = iterator.nextRtd
    # Return all nodes (IP addresses) in a given route
    return nodes